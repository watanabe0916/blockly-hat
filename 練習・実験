//mini-max最善の手を返す
function newminimax(data){
  let next = moves(data)
  let second =[];
  let third=[];
  let thirdscore=[];
  let resecond=[];
  let rethird=[];
  let lastscore=[];
  let xy1=[];
  let xy2=[];
  let t=[];
  let list1=[];
  turn=!turn;
  for (let i =0 ; i<next.length; i++){
      second.push(moves(next[i]));
      turn=turn;
      for (let j=0 ; j<second[i].length; j++){
        //if (xy1) > moves(second[i][j]){
          third.push(moves(second[i][j]));
          //}
          thirdscore.push(boardscore(second[i][j]));
          rethird.push(max(boardscore(second[i][j])));
          xy1.push([max(boardscore(second[i][j])),i]);
          thirdscore=[];
          if (rethird.length === second[i].length){
            resecond.push(min(rethird));
            xy2.push(min2(xy1));
            xy1=[];
            rethird=[];
          }    
        }
  }
  turn=!turn;
  return moves(data)[max2(xy2)[1]]
}






// === main定義エリア ===

// ゲーム開始前の準備
手番を選択する

// ゲームのメインループ
繰り返し (ゲームの終了条件を満たすまで)：
  もし 手番プレイヤーの石が置ける ならば：
    もし 現在の手番がユーザの手番 ならば：
      playerの操作
    そうでなければ：
      CPU関数を呼び出し

  そうでなければ：
    もし 相手プレイヤーの石が置ける ならば：
      手番交代する 
    そうでなければ：
      break

// ループ終了後の処理
勝敗判定・表示

// === 関数定義エリア ===

関数定義：
  CPU関数を呼び出し
    処理：
      オセロCPU
        アルゴリズム：
          アルファベータ探索

